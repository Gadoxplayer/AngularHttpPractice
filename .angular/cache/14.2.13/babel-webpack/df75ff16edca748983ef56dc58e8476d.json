{"ast":null,"code":"import _classCallCheck from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _possibleConstructorReturn from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _isNativeReflectConstruct from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\";\nimport _get from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport var ReplaySubject = /*#__PURE__*/function (_Subject) {\n  _inherits(ReplaySubject, _Subject);\n  function ReplaySubject() {\n    var _this;\n    var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n    var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    var scheduler = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, ReplaySubject);\n    _this = _callSuper(this, ReplaySubject);\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n    return _this;\n  }\n  _createClass(ReplaySubject, [{\n    key: \"nextInfiniteTimeWindow\",\n    value: function nextInfiniteTimeWindow(value) {\n      if (!this.isStopped) {\n        var _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n          _events.shift();\n        }\n      }\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"nextTimeWindow\",\n    value: function nextTimeWindow(value) {\n      if (!this.isStopped) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n      }\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      var _infiniteTimeWindow = this._infiniteTimeWindow;\n      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n      var scheduler = this.scheduler;\n      var len = _events.length;\n      var subscription;\n      if (this.closed) {\n        throw new ObjectUnsubscribedError();\n      } else if (this.isStopped || this.hasError) {\n        subscription = Subscription.EMPTY;\n      } else {\n        this.observers.push(subscriber);\n        subscription = new SubjectSubscription(this, subscriber);\n      }\n      if (scheduler) {\n        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n      }\n      if (_infiniteTimeWindow) {\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n          subscriber.next(_events[i]);\n        }\n      } else {\n        for (var _i = 0; _i < len && !subscriber.closed; _i++) {\n          subscriber.next(_events[_i].value);\n        }\n      }\n      if (this.hasError) {\n        subscriber.error(this.thrownError);\n      } else if (this.isStopped) {\n        subscriber.complete();\n      }\n      return subscription;\n    }\n  }, {\n    key: \"_getNow\",\n    value: function _getNow() {\n      return (this.scheduler || queue).now();\n    }\n  }, {\n    key: \"_trimBufferThenGetEvents\",\n    value: function _trimBufferThenGetEvents() {\n      var now = this._getNow();\n      var _bufferSize = this._bufferSize;\n      var _windowTime = this._windowTime;\n      var _events = this._events;\n      var eventsCount = _events.length;\n      var spliceCount = 0;\n      while (spliceCount < eventsCount) {\n        if (now - _events[spliceCount].time < _windowTime) {\n          break;\n        }\n        spliceCount++;\n      }\n      if (eventsCount > _bufferSize) {\n        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n      }\n      if (spliceCount > 0) {\n        _events.splice(0, spliceCount);\n      }\n      return _events;\n    }\n  }]);\n  return ReplaySubject;\n}(Subject);\nvar ReplayEvent = /*#__PURE__*/_createClass(function ReplayEvent(time, value) {\n  _classCallCheck(this, ReplayEvent);\n  this.time = time;\n  this.value = value;\n});","map":{"version":3,"names":["Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","SubjectSubscription","ReplaySubject","_Subject","_inherits","_this","bufferSize","arguments","length","undefined","Number","POSITIVE_INFINITY","windowTime","scheduler","_classCallCheck","_callSuper","_events","_infiniteTimeWindow","_bufferSize","_windowTime","next","nextInfiniteTimeWindow","nextTimeWindow","_createClass","key","value","isStopped","push","shift","_get","_getPrototypeOf","prototype","call","ReplayEvent","_getNow","_trimBufferThenGetEvents","_subscribe","subscriber","len","subscription","closed","hasError","EMPTY","observers","add","i","error","thrownError","complete","now","eventsCount","spliceCount","time","Math","max","splice"],"sources":["D:/Documents/Eduardo/UdemyCourses/Angularhttp-01-start/node_modules/rxjs/_esm2015/internal/ReplaySubject.js"],"sourcesContent":["import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        if (!this.isStopped) {\n            const _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}